# Generated from bnf.g4 by ANTLR 4.7
# encoding: utf-8
from antlr4 import *
from io import StringIO
from typing import TextIO
import sys

def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3$")
        buf.write("\u0089\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\3\2\3\2\3\2\3\3\5\3")
        buf.write("\33\n\3\3\3\5\3\36\n\3\3\3\7\3!\n\3\f\3\16\3$\13\3\3\3")
        buf.write("\3\3\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\7\4\60\n\4\f\4\16")
        buf.write("\4\63\13\4\3\4\3\4\3\5\3\5\3\5\3\5\7\5;\n\5\f\5\16\5>")
        buf.write("\13\5\3\5\3\5\3\6\3\6\3\6\3\6\3\6\3\6\3\7\3\7\3\7\3\7")
        buf.write("\3\7\3\7\3\7\3\7\3\7\3\7\3\7\7\7S\n\7\f\7\16\7V\13\7\3")
        buf.write("\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\5\7d\n")
        buf.write("\7\3\b\3\b\3\b\3\b\3\b\3\b\5\bl\n\b\3\t\5\to\n\t\3\t\3")
        buf.write("\t\3\t\7\tt\n\t\f\t\16\tw\13\t\3\n\3\n\3\n\7\n|\n\n\f")
        buf.write("\n\16\n\177\13\n\3\13\3\13\3\13\3\13\3\13\3\13\5\13\u0087")
        buf.write("\n\13\3\13\2\2\f\2\4\6\b\n\f\16\20\22\24\2\5\4\2\5\5\24")
        buf.write("\30\3\2\31\32\3\2\33\34\2\u008f\2\26\3\2\2\2\4\32\3\2")
        buf.write("\2\2\6\'\3\2\2\2\b\66\3\2\2\2\nA\3\2\2\2\fc\3\2\2\2\16")
        buf.write("k\3\2\2\2\20n\3\2\2\2\22x\3\2\2\2\24\u0086\3\2\2\2\26")
        buf.write("\27\5\4\3\2\27\30\7\3\2\2\30\3\3\2\2\2\31\33\5\6\4\2\32")
        buf.write("\31\3\2\2\2\32\33\3\2\2\2\33\35\3\2\2\2\34\36\5\b\5\2")
        buf.write("\35\34\3\2\2\2\35\36\3\2\2\2\36\"\3\2\2\2\37!\5\n\6\2")
        buf.write(" \37\3\2\2\2!$\3\2\2\2\" \3\2\2\2\"#\3\2\2\2#%\3\2\2\2")
        buf.write("$\"\3\2\2\2%&\5\f\7\2&\5\3\2\2\2\'(\7\4\2\2()\7!\2\2)")
        buf.write("*\7\5\2\2*\61\7\"\2\2+,\7\6\2\2,-\7!\2\2-.\7\5\2\2.\60")
        buf.write("\7\"\2\2/+\3\2\2\2\60\63\3\2\2\2\61/\3\2\2\2\61\62\3\2")
        buf.write("\2\2\62\64\3\2\2\2\63\61\3\2\2\2\64\65\7\7\2\2\65\7\3")
        buf.write("\2\2\2\66\67\7\b\2\2\67<\7!\2\289\7\6\2\29;\7!\2\2:8\3")
        buf.write("\2\2\2;>\3\2\2\2<:\3\2\2\2<=\3\2\2\2=?\3\2\2\2><\3\2\2")
        buf.write("\2?@\7\7\2\2@\t\3\2\2\2AB\7\t\2\2BC\7!\2\2CD\7\7\2\2D")
        buf.write("E\5\4\3\2EF\7\7\2\2F\13\3\2\2\2GH\7!\2\2HI\7\n\2\2Id\5")
        buf.write("\20\t\2JK\7\13\2\2Kd\7!\2\2LM\7\f\2\2Md\7!\2\2NO\7\r\2")
        buf.write("\2OT\5\f\7\2PQ\7\7\2\2QS\5\f\7\2RP\3\2\2\2SV\3\2\2\2T")
        buf.write("R\3\2\2\2TU\3\2\2\2UW\3\2\2\2VT\3\2\2\2WX\7\16\2\2Xd\3")
        buf.write("\2\2\2YZ\7\17\2\2Z[\5\16\b\2[\\\7\20\2\2\\]\5\f\7\2]d")
        buf.write("\3\2\2\2^_\7\21\2\2_`\5\16\b\2`a\7\22\2\2ab\5\f\7\2bd")
        buf.write("\3\2\2\2cG\3\2\2\2cJ\3\2\2\2cL\3\2\2\2cN\3\2\2\2cY\3\2")
        buf.write("\2\2c^\3\2\2\2d\r\3\2\2\2ef\7\23\2\2fl\5\20\t\2gh\5\20")
        buf.write("\t\2hi\t\2\2\2ij\5\20\t\2jl\3\2\2\2ke\3\2\2\2kg\3\2\2")
        buf.write("\2l\17\3\2\2\2mo\t\3\2\2nm\3\2\2\2no\3\2\2\2op\3\2\2\2")
        buf.write("pu\5\22\n\2qr\t\3\2\2rt\5\22\n\2sq\3\2\2\2tw\3\2\2\2u")
        buf.write("s\3\2\2\2uv\3\2\2\2v\21\3\2\2\2wu\3\2\2\2x}\5\24\13\2")
        buf.write("yz\t\4\2\2z|\5\24\13\2{y\3\2\2\2|\177\3\2\2\2}{\3\2\2")
        buf.write("\2}~\3\2\2\2~\23\3\2\2\2\177}\3\2\2\2\u0080\u0087\7!\2")
        buf.write("\2\u0081\u0087\7\"\2\2\u0082\u0083\7\35\2\2\u0083\u0084")
        buf.write("\5\20\t\2\u0084\u0085\7\36\2\2\u0085\u0087\3\2\2\2\u0086")
        buf.write("\u0080\3\2\2\2\u0086\u0081\3\2\2\2\u0086\u0082\3\2\2\2")
        buf.write("\u0087\25\3\2\2\2\16\32\35\"\61<Tcknu}\u0086")
        return buf.getvalue()


class bnfParser ( Parser ):

    grammarFileName = "bnf.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'.'", "'const'", "'='", "','", "';'", 
                     "'var'", "'procedure'", "':='", "'call'", "'!'", "'begin'", 
                     "'end'", "'if'", "'then'", "'while'", "'do'", "'odd'", 
                     "'#'", "'<'", "'<='", "'>'", "'>='", "'+'", "'-'", 
                     "'*'", "'/'", "'('", "')'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "WS", "Comment", "Ident", "Number", "ALPHA", 
                      "DIGIT" ]

    RULE_program = 0
    RULE_block = 1
    RULE_consts = 2
    RULE_plvars = 3
    RULE_procedure = 4
    RULE_statement = 5
    RULE_condition = 6
    RULE_expression = 7
    RULE_term = 8
    RULE_factor = 9

    ruleNames =  [ "program", "block", "consts", "plvars", "procedure", 
                   "statement", "condition", "expression", "term", "factor" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    T__8=9
    T__9=10
    T__10=11
    T__11=12
    T__12=13
    T__13=14
    T__14=15
    T__15=16
    T__16=17
    T__17=18
    T__18=19
    T__19=20
    T__20=21
    T__21=22
    T__22=23
    T__23=24
    T__24=25
    T__25=26
    T__26=27
    T__27=28
    WS=29
    Comment=30
    Ident=31
    Number=32
    ALPHA=33
    DIGIT=34

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.7")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None



    class ProgramContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def block(self):
            return self.getTypedRuleContext(bnfParser.BlockContext,0)


        def getRuleIndex(self):
            return bnfParser.RULE_program

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProgram" ):
                listener.enterProgram(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProgram" ):
                listener.exitProgram(self)




    def program(self):

        localctx = bnfParser.ProgramContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_program)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 20
            self.block()
            self.state = 21
            self.match(bnfParser.T__0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class BlockContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def statement(self):
            return self.getTypedRuleContext(bnfParser.StatementContext,0)


        def consts(self):
            return self.getTypedRuleContext(bnfParser.ConstsContext,0)


        def plvars(self):
            return self.getTypedRuleContext(bnfParser.PlvarsContext,0)


        def procedure(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(bnfParser.ProcedureContext)
            else:
                return self.getTypedRuleContext(bnfParser.ProcedureContext,i)


        def getRuleIndex(self):
            return bnfParser.RULE_block

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBlock" ):
                listener.enterBlock(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBlock" ):
                listener.exitBlock(self)




    def block(self):

        localctx = bnfParser.BlockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_block)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 24
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==bnfParser.T__1:
                self.state = 23
                self.consts()


            self.state = 27
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==bnfParser.T__5:
                self.state = 26
                self.plvars()


            self.state = 32
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==bnfParser.T__6:
                self.state = 29
                self.procedure()
                self.state = 34
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 35
            self.statement()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ConstsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Ident(self, i:int=None):
            if i is None:
                return self.getTokens(bnfParser.Ident)
            else:
                return self.getToken(bnfParser.Ident, i)

        def Number(self, i:int=None):
            if i is None:
                return self.getTokens(bnfParser.Number)
            else:
                return self.getToken(bnfParser.Number, i)

        def getRuleIndex(self):
            return bnfParser.RULE_consts

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConsts" ):
                listener.enterConsts(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConsts" ):
                listener.exitConsts(self)




    def consts(self):

        localctx = bnfParser.ConstsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_consts)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 37
            self.match(bnfParser.T__1)
            self.state = 38
            self.match(bnfParser.Ident)
            self.state = 39
            self.match(bnfParser.T__2)
            self.state = 40
            self.match(bnfParser.Number)
            self.state = 47
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==bnfParser.T__3:
                self.state = 41
                self.match(bnfParser.T__3)
                self.state = 42
                self.match(bnfParser.Ident)
                self.state = 43
                self.match(bnfParser.T__2)
                self.state = 44
                self.match(bnfParser.Number)
                self.state = 49
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 50
            self.match(bnfParser.T__4)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PlvarsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Ident(self, i:int=None):
            if i is None:
                return self.getTokens(bnfParser.Ident)
            else:
                return self.getToken(bnfParser.Ident, i)

        def getRuleIndex(self):
            return bnfParser.RULE_plvars

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPlvars" ):
                listener.enterPlvars(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPlvars" ):
                listener.exitPlvars(self)




    def plvars(self):

        localctx = bnfParser.PlvarsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_plvars)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 52
            self.match(bnfParser.T__5)
            self.state = 53
            self.match(bnfParser.Ident)
            self.state = 58
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==bnfParser.T__3:
                self.state = 54
                self.match(bnfParser.T__3)
                self.state = 55
                self.match(bnfParser.Ident)
                self.state = 60
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 61
            self.match(bnfParser.T__4)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ProcedureContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Ident(self):
            return self.getToken(bnfParser.Ident, 0)

        def block(self):
            return self.getTypedRuleContext(bnfParser.BlockContext,0)


        def getRuleIndex(self):
            return bnfParser.RULE_procedure

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProcedure" ):
                listener.enterProcedure(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProcedure" ):
                listener.exitProcedure(self)




    def procedure(self):

        localctx = bnfParser.ProcedureContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_procedure)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 63
            self.match(bnfParser.T__6)
            self.state = 64
            self.match(bnfParser.Ident)
            self.state = 65
            self.match(bnfParser.T__4)
            self.state = 66
            self.block()
            self.state = 67
            self.match(bnfParser.T__4)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class StatementContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Ident(self):
            return self.getToken(bnfParser.Ident, 0)

        def expression(self):
            return self.getTypedRuleContext(bnfParser.ExpressionContext,0)


        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(bnfParser.StatementContext)
            else:
                return self.getTypedRuleContext(bnfParser.StatementContext,i)


        def condition(self):
            return self.getTypedRuleContext(bnfParser.ConditionContext,0)


        def getRuleIndex(self):
            return bnfParser.RULE_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatement" ):
                listener.enterStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatement" ):
                listener.exitStatement(self)




    def statement(self):

        localctx = bnfParser.StatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_statement)
        self._la = 0 # Token type
        try:
            self.state = 97
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [bnfParser.Ident]:
                self.enterOuterAlt(localctx, 1)
                self.state = 69
                self.match(bnfParser.Ident)
                self.state = 70
                self.match(bnfParser.T__7)
                self.state = 71
                self.expression()
                pass
            elif token in [bnfParser.T__8]:
                self.enterOuterAlt(localctx, 2)
                self.state = 72
                self.match(bnfParser.T__8)
                self.state = 73
                self.match(bnfParser.Ident)
                pass
            elif token in [bnfParser.T__9]:
                self.enterOuterAlt(localctx, 3)
                self.state = 74
                self.match(bnfParser.T__9)
                self.state = 75
                self.match(bnfParser.Ident)
                pass
            elif token in [bnfParser.T__10]:
                self.enterOuterAlt(localctx, 4)
                self.state = 76
                self.match(bnfParser.T__10)
                self.state = 77
                self.statement()
                self.state = 82
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==bnfParser.T__4:
                    self.state = 78
                    self.match(bnfParser.T__4)
                    self.state = 79
                    self.statement()
                    self.state = 84
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 85
                self.match(bnfParser.T__11)
                pass
            elif token in [bnfParser.T__12]:
                self.enterOuterAlt(localctx, 5)
                self.state = 87
                self.match(bnfParser.T__12)
                self.state = 88
                self.condition()
                self.state = 89
                self.match(bnfParser.T__13)
                self.state = 90
                self.statement()
                pass
            elif token in [bnfParser.T__14]:
                self.enterOuterAlt(localctx, 6)
                self.state = 92
                self.match(bnfParser.T__14)
                self.state = 93
                self.condition()
                self.state = 94
                self.match(bnfParser.T__15)
                self.state = 95
                self.statement()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ConditionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(bnfParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(bnfParser.ExpressionContext,i)


        def getRuleIndex(self):
            return bnfParser.RULE_condition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCondition" ):
                listener.enterCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCondition" ):
                listener.exitCondition(self)




    def condition(self):

        localctx = bnfParser.ConditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_condition)
        self._la = 0 # Token type
        try:
            self.state = 105
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [bnfParser.T__16]:
                self.enterOuterAlt(localctx, 1)
                self.state = 99
                self.match(bnfParser.T__16)
                self.state = 100
                self.expression()
                pass
            elif token in [bnfParser.T__22, bnfParser.T__23, bnfParser.T__26, bnfParser.Ident, bnfParser.Number]:
                self.enterOuterAlt(localctx, 2)
                self.state = 101
                self.expression()
                self.state = 102
                _la = self._input.LA(1)
                if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << bnfParser.T__2) | (1 << bnfParser.T__17) | (1 << bnfParser.T__18) | (1 << bnfParser.T__19) | (1 << bnfParser.T__20) | (1 << bnfParser.T__21))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 103
                self.expression()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ExpressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def term(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(bnfParser.TermContext)
            else:
                return self.getTypedRuleContext(bnfParser.TermContext,i)


        def getRuleIndex(self):
            return bnfParser.RULE_expression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpression" ):
                listener.enterExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpression" ):
                listener.exitExpression(self)




    def expression(self):

        localctx = bnfParser.ExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_expression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 108
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==bnfParser.T__22 or _la==bnfParser.T__23:
                self.state = 107
                _la = self._input.LA(1)
                if not(_la==bnfParser.T__22 or _la==bnfParser.T__23):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 110
            self.term()
            self.state = 115
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==bnfParser.T__22 or _la==bnfParser.T__23:
                self.state = 111
                _la = self._input.LA(1)
                if not(_la==bnfParser.T__22 or _la==bnfParser.T__23):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 112
                self.term()
                self.state = 117
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class TermContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def factor(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(bnfParser.FactorContext)
            else:
                return self.getTypedRuleContext(bnfParser.FactorContext,i)


        def getRuleIndex(self):
            return bnfParser.RULE_term

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTerm" ):
                listener.enterTerm(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTerm" ):
                listener.exitTerm(self)




    def term(self):

        localctx = bnfParser.TermContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_term)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 118
            self.factor()
            self.state = 123
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==bnfParser.T__24 or _la==bnfParser.T__25:
                self.state = 119
                _la = self._input.LA(1)
                if not(_la==bnfParser.T__24 or _la==bnfParser.T__25):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 120
                self.factor()
                self.state = 125
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class FactorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Ident(self):
            return self.getToken(bnfParser.Ident, 0)

        def Number(self):
            return self.getToken(bnfParser.Number, 0)

        def expression(self):
            return self.getTypedRuleContext(bnfParser.ExpressionContext,0)


        def getRuleIndex(self):
            return bnfParser.RULE_factor

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFactor" ):
                listener.enterFactor(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFactor" ):
                listener.exitFactor(self)




    def factor(self):

        localctx = bnfParser.FactorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_factor)
        try:
            self.state = 132
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [bnfParser.Ident]:
                self.enterOuterAlt(localctx, 1)
                self.state = 126
                self.match(bnfParser.Ident)
                pass
            elif token in [bnfParser.Number]:
                self.enterOuterAlt(localctx, 2)
                self.state = 127
                self.match(bnfParser.Number)
                pass
            elif token in [bnfParser.T__26]:
                self.enterOuterAlt(localctx, 3)
                self.state = 128
                self.match(bnfParser.T__26)
                self.state = 129
                self.expression()
                self.state = 130
                self.match(bnfParser.T__27)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





